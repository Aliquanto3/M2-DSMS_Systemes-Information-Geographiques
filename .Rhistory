ComptePoint=read.csv(file = "TD6/ComptePoint.csv")
ComptePoint=read.csv(file = "TD6/ComptePoints.csv")
ComptePoint=read.csv(file = "TD6/ComptePoints.csv",sep=";")
ComptePoints=read.csv(file = "TD6/ComptePoints.csv",sep=";")
View(ComptePoints)
names(ComptesPoints)
names(ComptePoints)
X=ComptePoint$NUMPOINTS
mean(X)
sqrt(var(X))/mean(x)
sqrt(var(X))/mean(X)
table(X)
ppois(0:max(X),mean(X))
ppois(0:max(X),mean(X))*100
dpois(0:max(X),mean(X))
dpois(0:max(X),mean(X)) * sum(table(X))
Theo = dpois(0:max(X),mean(X)) * sum(table(X))
Chi2=sum((Theo-Obs)^2/Theo)
Obs=table(X)
Theo = dpois(0:max(X),mean(X)) * sum(table(X))
Chi2=sum((Theo-Obs)^2/Theo)
Obs
Theo
Obs
str(Obs)
Obs=matrix(table(X))
str(Obs)
Obs=data.frame(table(X))
str(Obs)
View(Obs)
Obs=data.frame(table(X))
str(Obs)
View(Obs)
for (i in 0:max(X)){
if (!i %in% Obs$X){
Obs[nrow(Obs) + 1,] = c(i,0)
}
}
View(Obs)
Obs$X=as.numeric(Obs$X)
Obs=data.frame(table(X))
str(Obs)
Obs$X=as.numeric(Obs$X)
for (i in 0:max(X)){
if (!i %in% Obs$X){
Obs[nrow(Obs) + 1,] = c(i,0)
}
}
View(Obs)
Theo
Obs=Obs[order(Obs$age),]
Obs=Obs[order(Obs$X),]
View(Obs)
ComptePoints=read.csv(file = "TD6/ComptePoints.csv",sep=";")
View(ComptePoints)
names(ComptePoints)
X=ComptePoint$NUMPOINTS
mean(X)
sqrt(var(X))/mean(X)
Obs=data.frame(table(X))
str(Obs)
View(Obs)
Obs$X=as.numeric(Obs$X)
for (i in 0:max(X)){
if (!i %in% Obs$X){
Obs[nrow(Obs) + 1,] = c(i,0)
}
}
Obs=Obs[order(Obs$X),]
#View(Obs)
Obs
Theo = dpois(0:max(X),mean(X)) * sum(table(X));Theo
Chi2=sum((Theo-Obs)^2/Theo)
Chi2=sum((Theo-Obs)^2/Theo);Chi2
Obs=Obs[order(Obs$X),]
#View(Obs)
Obs
J=length(Obs)
N=sum(table(X))
Theo = dpois(0:max(X),mean(X)) * N;Theo
Chi2=sum((Theo-Obs)^2/Theo);Chi2
qchisq(0.95,J)
Chi2=sum((Theo-Obs$Freq)^2/Theo);Chi2
qchisq(0.95,J)
1-pchisq(Chi2,J)
rectangle66=matrix(data = rep(NA,K*K),nrow=K,ncol=K)
K=6
rectangle66=matrix(data = rep(NA,K*K),nrow=K,ncol=K)
rectangleK=matrix(data = rep(NA,K*K),nrow=K,ncol=K)
View(rectangleK)
lambda=5
rpois(1,lambda)
coordx=runfi(3,0,1)
coordx=runif(3,0,1)
coordy=runif(3,0,1)
plot(coordx,coordy)
MatN=matrix(data = rpois(K*K,lambda),nrow=K,ncol=K)
MatN=matrix(data = rpois(K*K,lambda),nrow=K,ncol=K);MatN
set.seed(1)
coordX=NULL
coordY=NULL
for (i in 1:K){
for (j in 1:K){
coordX=c(coordX,runif(MatN[i,j],i-1))
coordY=c(coordY,runif(MatN[i,j],i-1))
}
}
K=6
lambda=3.5
MatN=matrix(data = rpois(K*K,lambda),nrow=K,ncol=K);MatN
set.seed(1)
coordX=NULL
coordY=NULL
for (i in 1:K){
for (j in 1:K){
coordX=c(coordX,runif(MatN[i,j],i-1,j))
coordY=c(coordY,runif(MatN[i,j],i-1,j))
}
}
plot(coordx,coordy)
set.seed(1)
K=6
lambda=3.5
MatN=matrix(data = rpois(K*K,lambda),nrow=K,ncol=K);MatN
coordX=NULL
coordY=NULL
for (i in 1:K){
for (j in 1:K){
coordX=c(coordX,runif(MatN[i,j],i-1,i))
coordY=c(coordY,runif(MatN[i,j],j-1,j))
}
}
plot(coordx,coordy)
plot(coordX,coordY)
library(statspat)
library(spatstat)
install.packages("spatstat")
#install.packages("spatstat")
library(spatstat)
rpoispp(3.5,win=owin(c(0,K),c(0,K)))
plot(rpoispp(3.5,win=owin(c(0,K),c(0,K))))
rectN=rpoispp(3.5,win=owin(c(0,K),c(0,K)))
plot(rectN)
?rpoispp
#Calcul Ripley
D=matrix(dist(c(coordX,coordY))) #sym et diagonale
image(D)
#Calcul Ripley
D=as.matrix(dist(c(coordX,coordY))) #sym et diagonale
image(D)
rayon=0.5
sort(D[1,])
sum(D[1,] > rayon)
sum(D[1,] < rayon)
?image
#Calcul Ripley
N=length(coordX)
D=as.matrix(dist(c(coordX,coordY))) #sym et diagonale
image(D)
rayon=0.5
sort(D[1,])
sum(D[1,] < rayon)
S=0
for (i in 1:N){
S=S+sum(D[i,]<rayon)
}
S
#Calcul Ripley
Surf=K*K
#Calcul Ripley
Surf=K*K
N=length(coordX)
D=as.matrix(dist(c(coordX,coordY))) #sym et diagonale
image(D)
rayon=0.5
sort(D[1,])
sum(D[1,] < rayon)
S=0
for (i in 1:N){
S=S+sum(D[i,]<rayon)
}
S
(Surf/(N*(N-1)))*S
pi
Resu=NULL
for (rayon in seq(0.01,2,0.01)){
S=0
for (i in 1:N){
S=S+sum(D[i,] < rayon)
Resu=c(Resu,(Surf/(N*(N-1)))*S
)
}
}
plot(seq(0.01,2,0.01),Resu)
Resu=NULL
for (rayon in seq(0.01,2,0.01)){
S=0
for (i in 1:N){
S=S+sum(D[i,] < rayon)
}
Resu=c(Resu,(Surf/(N*(N-1)))*S)
}
plot(seq(0.01,2,0.01),Resu)
plot(seq(0.01,2,0.01),Resu,pch=".")
lines(seq(0.01,2,0.01), pi*seq(0.01,2,0.01)^2,pch="+")
Points=read.csv("TD7/NO2")
getwd()
Points=read.csv("TD7/NO2.csv")
View(Points)
#View(Points)
D=as.matrix(dist(c(Points$X,Points$Y)))
#View(Points)
DistPoints=dist(c(Points$X,Points$Y))
#2. Transformez votre vecteur distances en matrice M.
D=as.matrix(DistPoints)
#View(Points)
DistPoints=dist(c(Points$X,Points$Y));DistPoints
#2. Transformez votre vecteur distances en matrice M.
D=as.matrix(DistPoints);D
dim(DistPoints)
length(DistPoints)
sqrt(length(DistPoints))
#View(Points)
DistPoints=dist(cbind(Points$X,Points$Y));DistPoints
length(DistPoints)
sqrt(length(DistPoints))
#2. Transformez votre vecteur distances en matrice M.
D=as.matrix(DistPoints,96;96);D
#2. Transformez votre vecteur distances en matrice M.
M=as.matrix(DistPoints,96,96);M
image(M)
# 1. Sous R , transformez ces coordonnees en dataset : Points. Puis calculez les distances
# au moyen de la fonction dist.
Points=read.csv("TD7/NO2.csv")
#View(Points)
DistPoints=dist(cbind(Points$X,Points$Y));DistPoints
#View(Points)
DistPoints=dist(cbind(Points$X,Points$Y))
length(DistPoints)
#2. Transformez votre vecteur distances en matrice M.
M=as.matrix(DistPoints,nrow(Points),nrow(Points));M
image(M)
# 1. Sous R , transformez ces coordonnees en dataset : Points. Puis calculez les distances
# au moyen de la fonction dist.
Points=read.csv("TD7/NO2.csv")
#View(Points)
DD=dist(cbind(Points$X,Points$Y))
length(DD)
#2. Transformez votre vecteur distances en matrice M.
M=as.matrix(DD,nrow(Points),nrow(Points));M
image(M)
hist(DD)
rayon=quantil(DD,0.05)
rayon=quantile(DD,0.05)
image(M<rayon)
W=M<rayon
apply(W,1,sum)
plot(apply(W,1,sum))
diag(W)=0
plot(apply(W,1,sum))
plot(table(apply(W,1,sum)))
# 1. Sous R , transformez ces coordonnees en dataset : Points. Puis calculez les distances
# au moyen de la fonction dist.
NO2=read.csv("TD7/NO2.csv")
#View(NO2)
DD=dist(cbind(NO2$X,NO2$Y))
length(DD)
#2. Transformez votre vecteur distances en matrice M.
M=as.matrix(DD,nrow(NO2),nrow(NO2));M
image(M)
hist(DD)
rayon=quantile(DD,0.05)
image(M<rayon)
W=M<rayon
diag(W)=0
plot(table(apply(W,1,sum)))
plot(No2$X,NO2$Y)
plot(NO2$X,NO2$Y)
# 1. Sous R , transformez ces coordonnees en dataset : Points. Puis calculez les distances
# au moyen de la fonction dist.
NO2=read.csv("TD7/NO2.csv")
#View(NO2)
DD=dist(cbind(NO2$X,NO2$Y))
length(DD)
#2. Transformez votre vecteur distances en matrice M.
M=as.matrix(DD,nrow(NO2),nrow(NO2));M
image(M)
hist(DD)
rayon=quantile(DD,0.05)
image(M<rayon)
rayon
#4. Transformez votre matrice M en W qui somme a 1.
W=W/sum(W)
# 1. Sous R , transformez ces coordonnees en dataset : Points. Puis calculez
#les distances au moyen de la fonction dist.
NO2=read.csv("TD7/NO2.csv")
plot(NO2$X,NO2$Y)
#View(NO2)
DD=dist(cbind(NO2$X,NO2$Y))
length(DD)
#2. Transformez votre vecteur distances en matrice M.
M=as.matrix(DD,nrow(NO2),nrow(NO2));M
image(M)
hist(DD)
# 3. Fixez un seuil ( prendre au debut le quantile a 2.5 %. Mettez le resultat
#dans une matrice W. Affectez 0 a la diagonale
rayon=quantile(DD,0.05)
image(M<rayon)
W=M<rayon
diag(W)=0
#4. Transformez votre matrice M en W qui somme a 1.
W=W/sum(W)
#plot(table(apply(W,1,sum)))
# 5. Calculez l'expression donnee par Saporta pour le coefficient de Moran et
# comparez a la valeur attendue sous l'hypothese H0
#4. Transformez votre matrice M en W qui somme a 1.
W=W/sum(W);sum(W)
Z=NO2
Y=scale(Z)
Z
Y
?scale
(t(Y) %*% W * Y)
(t(Y) %*% W %*% Y)
?subset
Z=subset(NO2,select=c(X,Y))
?scale
Y=scale(Z)
Y=scale(Z);head(Y)
Z=subset(NO2,select=c(X,Y));head(Z)
?scale
Y=scale(Z);head(Y)
(t(Y) %*% W %*% Y)
var(Y)
head(NO2)
Z=NO2$NO2;head(Z)
?scale
Y=scale(Z);head(Y)
I = (t(Y) %*% W %*% Y) / var(Y);I
I = (t(Y) %*% W %*% Y);I
Z=NO2$NO2;head(Z)
# ?scale #divise par n-1 au lieu de n
# Y=scale(Z);head(Y)
Y=PCA(Z, scale.unit = TRUE, ncp=2);head(Y)
# ?scale #divise par n-1 au lieu de n
# Y=scale(Z);head(Y)
library(FactoMineR)
Y=PCA(Z, scale.unit = TRUE, ncp=2);head(Y)
Y=PCA(Z, scale.unit = TRUE, ncp=2);head(Y$ind$coord)
Y=PCA(Z, scale.unit = TRUE, ncp=2)$ind$coord;head(Y)
I = t(Y) %*% W %*% Y;I
Z=(Z-mean(Z))/(sd(Z)*sqrt(n/n-1))
# #On peut aussi utiliser une PCA pour centrer en divisant par n
# library(FactoMineR)
# Y=PCA(Z, scale.unit = TRUE, ncp=2)$ind$coord;head(Y)
n=dim(W)[1]
# #On peut aussi utiliser une PCA pour centrer en divisant par n
# library(FactoMineR)
# Y=PCA(Z, scale.unit = TRUE, ncp=2)$ind$coord;head(Y)
n=dim(W)[1];n
Z=(Z-mean(Z))/(sd(Z)*sqrt(n/n-1));Z
Z=(Z-mean(Z))/(sd(Z)*sqrt(n/(n-1)));Z
Z=NO2$NO2;head(Z)
Z=(Z-mean(Z))/(sd(Z)*sqrt(n/(n-1)));Z
Y=(Z-mean(Z))/(sd(Z)*sqrt(n/(n-1)));Y
I = t(Y) %*% W %*% Y;I
Y=(Z-mean(Z))/(sd(Z)*sqrt((n-1)/n));Y
I = t(Y) %*% W %*% Y;I
Z=NO2$NO2;head(Z)
#En revenant à la formule théorique
n=dim(W)[1];n
Y=(Z-mean(Z))/(sd(Z)*sqrt((n-1)/n));Y
I = t(Y) %*% W %*% Y;I
W=W/sum(W);sum(W)
I = t(Y) %*% W %*% Y;I
Moran = function(X,Y,Z,rayon){
n=length(Z)
DD=dist(cbind(NO2$X,NO2$Y))
M=as.matrix(DD,n,n)
W=M<rayon
diag(W)=0
W=W/sum(W)
Y=(Z-mean(Z))/(sd(Z)*sqrt((n-1)/n))
t(Y) %*% W %*% Y
}
Moran(NO2$X,NO2$Y,NO2$NO2,rayon)
resu=NULL
NO2P=sample(NO2$NO2)
resu=NULL
for (k in 1:1000){
NO2P=sample(NO2$NO2)
resu=c(resu,Moran(NO2$X,NO2$Y,NO2P,rayon))
}
hist(resu)
install.packages("Moran.I")
install.packages("Moran")
install.packages("ape")
#install.packages("ape")
library(ape)
Moran.I(NO2$NO2,W)
Moran(NO2$X,NO2$Y,NO2$NO2,rayon)
n=dim(W)[1];n
Y=(Z-mean(Z))/(sd(Z)*sqrt((n-1)/n));Y
I = t(Y) %*% W %*% Y;I
Moran.I(NO2$NO2,W)
